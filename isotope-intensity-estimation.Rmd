---
title: "Estimating isotope peak intensities for compounds defined in HMDB"
author: "Andrea Vicini, Johannes Rainer"
output:
  rmarkdown::html_document:
    highlight: pygments
    toc: true
    toc_depth: 3
    fig_width: 5
---

```{r style, echo = FALSE, results = 'asis', message = FALSE}
library(BiocStyle)
knitr::opts_chunk$set(echo = TRUE, message = FALSE)
```

**Last modified:** `r file.info("isotope-intensity-estimation.Rmd")$mtime`<br />
**Compiled**: `r date()`

# Introduction

In this document we evaluate possibilities to estimate abundances for isotopes
without knowing the chemical formula for the compound. To this end we analyze
the element composition of all compounds in the human metabolome database
([HMDB](https://hmdb.ca)).

The ultimate goal would be to have one or more functions that allow to identify
peaks in (MS1) spectra representing isotopes of the same compound based
exclusively on the m/z and intensity values, i.e. without knowing the chemical
formula of the compound. The functions should be modular and customizable and
should support low as well as high resolution instruments that would allow to
discriminate between isotope peaks from different elements.


# Isotope detection approaches


## `CAMERA`

[`CAMERA`](https://bioconductor.org/packages/release/bioc/html/CAMERA.html)
takes a simple approach based on hard coded lower and upper limits for isotope
peaks. How this limits were defined is unclear. For the m/z differences of the
peaks simple lower and upper limits are used, not discriminating between
e.g. C13 and N15 isotopes.

## `envipat`

[`envipat`](https://cran.r-project.org/web/packages/enviPat/) does not seem to
allow identifying isotopes in MS data but does predict an isotope (intensity)
distribution from a chemical formula.


## Breen et al. 2000. Automatic poisson peak harvesting for high throughput protein identification

The authors consider Poisson modelling of isotopic distributions. Given a 
molecule with mass m they find a mapping F between m and the mean M of the 
Poisson distribution model (F: m-> M).
To compute this mapping they derive from a database a hypothetical average 
aminoacid. Next they use this to construct a set of the theoretical peptides 
whose mass span a certain range of interest. They compute the isotopic 
distribution of those and for each one of them they compute M* as the value of M 
that makes Poisson(M) more similar to the isotopic distribution. Finally they 
fit a line for the values of m against the M* and this line represents the 
mapping F. In the end, they model the isotopic distribution of a compound with 
mass m as a Poisson(P(M))

## Park et al. 2008. Isotopic peak intensity ratio based algorithm for determination of isotopic clusters and monoisotopic masses of polypeptides from high-resolution mass spectrometric data

The following statements are reported for the isotopic distribution of a compound 
with elements C, H, N, O, S.
- the intensity of a peak Ik approximates to a polynomial in m (molecular weight) 
  with degree k
- the ratio between consecutive peaks (R) approximates to a linear function in m
- the ratio product between adjacent peaks (RP) approximates to a constant.

For the last two, the more m is big the better the above approximations get.

To find a relation between R and m they consider a large number of polypeptides 
in a certain database spanning a certain range (400-5200 Da) and for them 
they compute R. Then, the interval of interest is divided in two regions 
(at 1800 Da). For high masses a linear approximation is used and 
its coefficients are found by fitting a regression line whereas for low masses
they use a quotient of polynomials (with degree k+1 and k for the k-th R)

The algorithm to cluster isotopic peaks after peak peaking) involves:

- pseudocluster identification. It requires to loop over all the peaks and for
  each of them find groups of peaks starting with the current peak and separated
  by +1 (in the single charged case) for each peak. They first enumerate
  pseudoclusters with two peaks, then pseudoclusters with more peaks and then
  proceed by considering different charged states.
- isotopic cluster identification. Among the pseudoclusters, they identify
  isotopic clusters whose intensity patterns are similar to those of the
  isotopic distributions in terms of R and RP in the pseudocluster.
- duplicate cluster removal. In case two clusters overlap they remove the one
  whose most abundant peak is smaller. If the most abundant peaks are the same,
  the one with the lowest charge state is removed. If their charge states are
  also the same, the cluster with the lower "similarity score" is removed.

## Valkenborg et al. 2008. A Model-Based Method for the Prediction of the Isotopic Distribution of Peptides

Also in this article the authors consider the ratios between peak heights.
They model it as a polynomial model in m (monoisotopic mass) whose order 
is empirically determined by looking at the improvements obtained by adding 
higher order terms.
The parameters of the polynomial model are estimated using the least-squares 
method on different sets of theoretical peptides (and the model is valid in the 
corresponding mass range).
By comparing the ratios between a series of peaks observed in a spectrum with 
the ratios predicted from the model and selecting a treshold for the allowed 
"difference" they decide whether the series of peaks is part of an isotopic group
or not.

## sgibb

As far as I have understood sgibb uses a mixed approach. He uses the approach of 
Park et al. 2008 but for checking if a candidate cluster is a isotope cluster, 
for which he uses the Poisson approach of Breen et al. 2000.


# Element counts in HMDB

In this section we analyze element compositions of compounds from the Human
Metabolome Database.

```{r libraries, warning = FALSE}
library("CompoundDb")
library("MetaboCoreUtils")
library("pander")
```

We load the HMDB database and extract the chemical formula and exact mass of all
compounds.

```{r}
cdb <- CompDb("data/CompDb.Hsapiens.HMDB.4.0.sqlite")
#cdb <- CompDb("~/CompDb.Hsapiens.HMDB.4.0.sqlite")
cmps <- compounds(cdb, columns = c("compound_id", "name",
                                   "formula", "exactmass"))
```

We next define the (**single charged**) isotopes which we will consider along
with their natural occurring relative abundance.

```{r}
isotopes <- data.frame(
    element = c("C", "C", "N", "O", "O", "S", "S", "Cl"),
    isotope = c("C13", "2C13", "N15", "O17", "O18", "S33", "S34", "Cl37"),
    number_neutrons = c(1, 1, 1, 1, 2, 1, 2, 1),
    number_isotopes = c(1, 2, 1, 1, 1, 1, 1, 1),
    mass_diff = c(1.00335484, 2.00670968, 0.997034965599999, 1.0042168777,
                  2.0042457777, 0.999387810000002, 1.99579614, 1.99704989),
    element_abundance = c(0.9893, 0.9893, 0.99636, 0.99757,
                          0.99757, 0.9499, 0.9499, 0.7576),
    isotope_abundance = c(0.0107, 0.0107, 0.00364, 0.00038,
                          0.00205, 0.0075, 0.0425, 0.2424)
)


isotopes_2 <- list(C = c(0.9893, 0.0107), 
                   N = c(0.99636, 0.00364), 
                   O = c(0.99757, 0.00038, 0.00205),
                   S = c(0.9499, 0.0075, 0.0425),
                   Cl = c(0.7576, 0.2424))
```

The table below lists the defined isotopes.

```{r, echo = FALSE, results = "asis"}
pandoc.table(isotopes, style = "rmarkdown",
             caption = "Isotope definitions.")
```

For each compound in the human metabolom database (HMDB) we compute how many 
atoms of C, H, N, O, P and S are present in it. 
We collect the counts in a data frame with a column for each element and a row 
for each compound in HMDB.

```{r}
cmps <- cmps[-which(is.na(cmps$exactmass)), ]
```

```{r}
CHNOPS <- c("C", "H", "N", "O", "P", "S", "Cl")
counts <- lapply(cmps$formula, function(frml) {
  res <- countElements(frml)
  row <- data.frame(matrix(0, nrow = 1, ncol = length(CHNOPS)))
  names(row) <- CHNOPS
  only <- intersect(CHNOPS, names(res))
  row[1, only] <- res[only]
  row
  })
counts_df <- do.call(rbind, counts)
rownames(counts_df) <- cmps$compound_id
```

We compute the mean and standard deviation for the number of each element in the
molecules of HMDB.

```{r, echo = FALSE, results = "asis"}
m_sd <- rbind(colMeans(counts_df), 
              apply(counts_df, 2, sd),
              100 * colSums(counts_df > 0) / nrow(counts_df))
rownames(m_sd) = c("mean", "standard deviation", "% compounds with count > 0")
pandoc.table(m_sd, style = "rmarkdown")
```

We plot, for each of the considered elements, the distribution of the number of 
atoms of the given element in the compounds of HMDB.

```{r distribution-counts, fig.cap = "Distribution of the number of atoms of CHNOPS elements in compounds of HMDB.", fig.width = 7, fig.height = 14, echo = FALSE}
par(mfrow = c(7, 1), mar = c(3, 4, 1, 0.5))
for (el in CHNOPS) {
  hist(counts_df[, el], xlab = "", main = el, breaks = 256)
  abline(v = quantile(counts_df[, el], c(0.025, 0.975)))
}
```

## Define lower and upper intensity limits covering most compounds

We next define a lower and upper intensity limit for a given isotope of an
element based on the probability of such an isotope independently of the
chemical formula or the mass of the ion. Thus, the limits have to be set to
span a rather large range to cover most compounds in HMDB.

We below compute for each molecule in HMDB the probability that the molecule has 
a certain number (e.g. 1) of isotopes of a given element. Note that we drop
below the count for *H* because the natural occurrence of it's isotope(s) is too
low.

```{r}
counts_df <- counts_df[, colnames(counts_df) != "H"]

#' Simple helper function to calculate probabilities from counts
prob_from_counts <- function(x, def) {
    res <- lapply(seq_len(nrow(def)), function(i) {
        niso <- def$number_isotopes[i]
        sapply(x[, def$element[i]], function(n)
            ifelse(n > (niso - 1),
                   dmultinom(c(n - niso, niso),
                             prob = c(def$element_abundance[i],
                                      def$isotope_abundance[i])), 0))
    })
    res <- do.call(cbind, res)
    colnames(res) <- def$isotope
    res
}
prob_df <- prob_from_counts(counts_df, isotopes)

## ??? Is the above correct???

prob_df_2 <- cbind(
    `C13` = sapply(counts_df$C, function(n)
        ifelse(n > 0, dmultinom(c(n - 1, 1), prob = isotopes_2$C), 0)),
    `2C13` = sapply(counts_df$C, function(n)
        ifelse(n > 1, dmultinom(c(n - 2, 2), prob = isotopes_2$C), 0)),
    `N15` = sapply(counts_df$N, function(n)
        ifelse(n > 0, dmultinom(c(n - 1, 1), prob = isotopes_2$N), 0)),
    `O17` = sapply(counts_df$O, function(n)
        ifelse(n > 0, dmultinom(c(n - 1, 1, 0), prob = isotopes_2$O), 0)),
    `O18` = sapply(counts_df$O, function(n)
        ifelse(n > 0, dmultinom(c(n - 1, 0, 1), prob = isotopes_2$O), 0)),
    `S33` = sapply(counts_df$S, function(n)
        ifelse(n > 0, dmultinom(c(n - 1, 1, 0), prob = isotopes_2$S), 0)),
    `S34` = sapply(counts_df$S, function(n)
        ifelse(n > 0, dmultinom(c(n - 1, 0, 1), prob = isotopes_2$S), 0)),
    `Cl37` = sapply(counts_df$Cl, function(n)
        ifelse(n > 0, dmultinom(c(n - 1, 1), prob = isotopes_2$Cl), 0)))
```

```{r, fig.width = 7, fig.height = 20, fig.cap = "Distribution of probabilities for a certain isotope."}
par(mfrow = c(ncol(prob_df), 2), mar = c(2, 4, 1, 0.5))
for (name in colnames(prob_df)) {
  hist(prob_df[, name], probability = TRUE, main = name, xlab = "", breaks = 64)
  boxplot(prob_df[, name], main = name)
  #print(paste0(name," : ", quantile(v, 0.8)))
}
```

The lower and upper intensity threshold for a certain isotope is defined on the
probability of observing the isotope for most of the compounds from HMDB
(regardless of their total number of atoms or mass).

The probability to observe a mz difference related to atom X in a compound 
depends on nX (number of atoms of type X in the compound). We can determine two 
quantiles q1 and q2 such that a certain percentage (e.g 95%) of compounds in 
HMBD have q1<nX<q2 and based on q1 and q2 compute an upper bound and a lower 
bound for the relative intensities. Equivalently we could look directly at the 
distribution of probabilities of observing a given mz difference in HMBD 
compounds. In this case we could select as upper and lower bound for the 
relative intensity two quantiles q1 and q2 such that a certain percentage 
(e.g 95%) of compounds in HMBD have q1<P(observe mz)<q2.

Below we define for each element the 2.5 and 97.5% quantile of element counts
for all compounds in HMDB. These limits cover thus the intensity range for 95%
of all HMDB compounds.

```{r}
count_limits <- apply(counts_df, 2, quantile, probs = c(0.025, 0.975))
```

We next define for these lower and upper element count limits the probability of
a certain isotope.

```{r}
prob_limits <- prob_from_counts(count_limits, isotopes)
```

Below we plot the probability for a certain isotope against the number of atoms
for that element in HMDB.

```{r, fig.width = 7, fig.height = 20}
par(mfrow = c(ncol(prob_df), 1), mar = c(4, 4, 1, 0.5))
for (name in colnames(prob_df)) {
    el <- gsub('[0-9]+', '', name)
    plot(counts_df[, el], prob_df[, name], 
         main = name, xlab = "counts", ylab = "probability")
    abline(v = count_limits[, el], col = "red")
}
```

This approach has the following limitations, mostly because it is based on all
compounds in HMDB regardless of their mass:
- the lower limit for C13 might be too large, because of the lower limit of
  carbon atom counts used (i.e. `r count_limits[1, "C"]`). The lower intensity
  threshold will be too large for all compounds with less C atoms.
- for *Cl37* both the lower and upper intensity limit is 0, thus we will never
  identify any such isotope.

```{r}
prob_limits <- t(prob_limits)
colnames(prob_limits) <- c("intensity_low", "intensity_high")
isotopes <- cbind(isotopes, prob_limits)

dr <- paste0("data/txt/isotope-intensity-estimation/")
dir.create(dr, showWarnings = FALSE, recursive = TRUE)
write.table(isotopes, file = paste0(dr, "hmdb_isotopes_constant_range.txt"),
            sep = "\t", row.names = FALSE)
```

TODO:

- [ ] Should we consider to lower the count for C13 (i.e. set it manually to 1)?
- [ ] For Cl37, should we increase the upper count?
- [ ] Should we use the `range` instead of the quantiles?


## Define mass-dependent lower and upper intensity limits

The higher the compounds mass the larger the number of its atoms and hence also
the probability of an isotope of a specific element.

We next evaluate what the relationship between the compound's mass and its
number of specific atoms. We could use this later to determine a mass-dependent
factor to estimate the expected intensity of a certain isotope.

We try to fit a regression line for masses of molecules versus the number of 
atoms for the elements C, N, O, S, Cl.

```{r, fig.width = 7, fig.height = 20}
par(mfrow = c(5, 1), mar = c(3, 4, 1, 0.5))
for (el in c("C", "N" , "O", "S", "Cl")) {
counts_el <- counts_df[, el]
exactmass <- cmps$exactmass
# idx <- which(counts_df[, el] > 0 )#& exactmass<300)
# counts_el <- counts_el[idx]
# exactmass <- exactmass[idx]

lm <- lm(counts_el ~ exactmass)
plot(counts_el ~ exactmass, ylab = "counts", xlab = "exactmass", main = el)
abline(lm , col = "red")
}
```

```{r}
# A closer look on C. Attempt to find prediction intervals, but the hypoteses behind
# regression are not fulfilled so this approach probably doesn't make much sense
# countsC <- counts_df[, "C"]
# exactmass <- cmps$exactmass
# lmC <- lm(countsC ~ exactmass)
# 
# #summary(lmC)
# # plot(hist(residuals(lmC), breaks = 100))
# # shapiro.test(sample(residuals(lmC), size = 5000))
# # the residuals doesn't appear to be normal so this approach probably doesn't 
# # make sense
# 
# z0   <- data.frame(exactmass = seq(min(cmps$exactmass), max(cmps$exactmass), 
#                                    len = 1000))
# alpha = .05
# Conf <- predict.lm(lmC, z0, interval="confidence", level = 1 - alpha)
# Pred <- predict.lm(lmC, z0, interval="prediction", level = 1 - alpha)
# 
# plot(cmps$exactmass, countsC)
# lines(z0[, 1], Conf[, "fit"])
# lines(z0[, 1], Conf[, "lwr"], lty = 2, col = "red", lwd = 2)
# lines(z0[, 1], Conf[, "upr"], lty = 2, col = "red", lwd = 2)
# 
# lines(z0[, 1], Pred[, "lwr"], lty = 3, col = "gold", lwd=2)
# lines(z0[, 1], Pred[, "upr"], lty = 3, col = "gold", lwd=2)
```


```{r}
# Compute the slope of line through the origin and each (count, mass) point
slp <- counts_df/cmps$exactmass
q_slp <- apply(slp, 2, function(x) quantile(x, c(0.01, 0.999))) # values to be chosen
```

For each element we fit a regression to the points with top and low (?%) 
of the value of slp.
```{r, fig.width = 7, fig.height = 20}
#Iâ€™m not sure if maybe it would be best to fit a regression line through the 
# origin (i.e removing the intercept from the lm estimation).
par(mfrow = c(5, 1), mar = c(3, 4, 1, 0.5))
for (el in c("C", "N" , "O", "S", "Cl")) {
high <- which(slp[, el] > q_slp[2, el])
low <- which(slp[, el] <= q_slp[1, el])
plot(cmps$exactmass, counts_df[, el], ylab = "counts", xlab = "exactmass", 
     main = el)
points(cmps$exactmass[low], counts_df[low, el], col = "green")
points(cmps$exactmass[high], counts_df[high, el], col = "blue")
lm_l <- lm(counts_df[low, el] ~ cmps$exactmass[low])
lm <- lm(counts_df[, el] ~ cmps$exactmass)
lm_h <- lm(counts_df[high, el] ~ cmps$exactmass[high])
abline(lm_l, col)
abline(lm, col = "red")
abline(lm_h)
}
```

TODO

- [ ] decide how to define the lower and upper bound. Should we exclude count of
      0 (since if we look for an isotope of a certain element we (should) expect
      that the compound contains at least one atom - otherwise we would anyway
      not detect/find the isotope)?
- [ ] define intercept and slope for lower and upper bound (number of atoms
      depending on mass).
- [ ] isotope detection function: have a function that takes that and, given a
      mass (or m/z) calculates the lower and upper count of atoms and from that
      calculates the probability. The *isotope definition* `data.frame` should
      contain all the required information to perform that calculation and
      should be passed along to this function.







# Session information

The R version and packages used in this analysis are listed below.

```{r sessioninfo}
sessionInfo()
```
