---
title: "Internal Standards: Matrix effect - Evaluation XCMS"
author: "Mar Garcia-Aloy"
output: 
  BiocStyle::html_document:
    toc: true
    number_sections: false
    toc_float: true
---

```{r include = FALSE}
knitr::opts_chunk$set(echo=TRUE)

startpoint <- Sys.time()
```

In this document I'm going to check the quality of the data obtained after processing raw files with XCMS. For that I'm going to focus first of all to the 20 IS and later also to the 200 STDs. Different things to look for are to check if there is only 1 detected peak per compound (peak detection step), as well as, 1 feature per compound (correspondance step). I'll check that separately for ISs and for QC-serum samples. The group of samples that are going to be used is specified in the parameter "study" (in section "preliminaries" - "parameters").

# Preliminaries
I define the specific parameters for the current study, I load all required libraries, and I set up the parallel processing.

## Parameters
```{r, echo=TRUE}
polarity <- "POS" # specify "POS" or "NEG"
study <- "IS"     # specify "IS" or "QC"
mz.d <- 0.01
rt.d <- 10
dir.create(paste0("images/", study, "/", polarity, "/default"), 
                  recursive = TRUE, showWarnings = FALSE)
```

## Libraries
```{r, message=FALSE, warning=FALSE}
library(doParallel)
library(xcms)
library(RColorBrewer)
library(Rdisop)
library(CompoundDb)
```

## Parallel processing
```{r}
ncores <- detectCores()-1
registerDoParallel(ncores)
register(DoparParam(), default = TRUE)
```

## Data import
```{r}
load(paste0("XCMS_", polarity, "_", study, ".Rdata"))
```

## Colouring factors
Also, I define colors to be used for the various experimental groups throughout the experiment.
```{r}
xdata$class <- factor(xdata$class)
if (study == "IS") {
  col_class <- brewer.pal(length(levels(xdata$class))+1, "Set1")[-2]
} else if (study == "QC") {
  col_class <- brewer.pal(length(levels(xdata$class)), "Set1")
}
names(col_class) <- levels(xdata$class)
plot(NULL ,xaxt='n',yaxt='n',bty='n',ylab='',xlab='', xlim=0:1, ylim=0:1)
legend("topleft", legend = names(col_class),
       col = col_class, pch = 16, pt.cex=3, cex=1.5, bty='n')
mtext("Class", at=0.2, cex=2)
```

## Standards library
### Import
```{r}
std_info <- read.table(
    "https://raw.githubusercontent.com/EuracBiomedicalResearch/lcms-standards/master/data/internal_standards.txt",
    sep = "\t", header = TRUE, as.is = TRUE)
```

### Quality
```{r}
std_info$quality <- c(NA,      # succinic
                      "LP",    # creatinine
                      "2P",    # glucose
                      "LP",    # carnitine
                      "2F_2P", # alanine        QC = OK
                      "OK",    # arginine
                      "2F_2P", # aspartic       QC = LP
                      "OK",    # cysteine
                      "OK_2P", # glutamic       QC = OK
                      "OK",    # glycine        QC = MS
                      "OK_2P", # histidine
                      NA,      # isoleucine
                      "LP",    # leucine
                      "OK_2P", # lysine
                      "2F_2P", # methionine
                      "2F_2P", # phenylalanine
                      "2F_2P", # proline
                      "OK_2P", # serine
                      "OK_2P", # threonine
                      "2F",    # tyrosine
                      "2F_2P"  # valine
                      )
```

### Additional formating
```{r}
std_info <- std_info[!is.na(std_info[, grep(polarity, 
                                            colnames(std_info))]),]
std_info <- std_info[!grepl("Isoleucine", std_info$name),]
rownames(std_info) <- seq(nrow(std_info))

std_info$mzneut = NA
std_info$mz <- NA
for(i in seq(nrow(std_info))){
  if(grepl("C", std_info$formula[i])){std_info$mzneut[i] = 
    getMolecule(as.character(std_info$formula[i]))$exactmass}else{
      std_info$mzneut[i] = as.numeric(std_info$formula[i])}
  std_info$mz[i] <- unlist(
        mass2mz(std_info$mzneut[i],
                adduct = as.character(
                    std_info[i, grep(polarity, colnames(std_info))])))
}
```

# Workflow
```{r}
for(i in seq(nrow(std_info))){ # for each IS do the following:
  
  mz.i <- std_info$mz[i]
  rt.i <- std_info$RT[i]
  cmpname <- tolower(gsub(" .*", "", std_info$name[i]))
  cmpname <- gsub("l-", "", cmpname)
  
  # PEAK DETECTION
  chr <- chromatogram(xdata, mz = c((mz.i - mz.d), (mz.i + mz.d)),
                      aggregationFun = "max")
  if(nrow(featureDefinitions(chr)) == 1){
    ft <- rownames(featureDefinitions(chr))
  } else if (nrow(featureDefinitions(chr)) > 1){
    ft <- rownames(featureDefinitions(chr))[
      which.max(rowMeans(featureValues(chr, value = "into"), 
                         na.rm = TRUE))]
  }
  ft_chr <- featureChromatograms(xdata, features = ft)
  
  filename <- paste0("images/", study, "/", polarity, "/default/",
                     std_info$quality[i], "_", cmpname, "_FT.png")
  png(file = filename, width = 1000, height = 500)
  par(mfrow = c(1,2))
  plot(ft_chr, col = "#00000040", 
     peakCol = col_class[xdata$class[chromPeaks(ft_chr)[, "column"]]],
     peakBg = 
       paste0(col_class[xdata$class[chromPeaks(ft_chr)[, "column"]]],
              "10"))
  plot(ft_chr, col = "#00000040", 
       peakCol = col_class[xdata$class[chromPeaks(ft_chr)[, "column"]]],
       peakBg = paste0(col_class[
         xdata$class[chromPeaks(ft_chr)[, "column"]]], "10"))
  xcms:::.add_chromatogram_peaks(
    ft_chr, chromPeaks(ft_chr),
    col = col_class[xdata$class[chromPeaks(ft_chr)[, "column"]]],
    bg = NA,
    type = "rectangle")
  dev.off()
  
  # CORRESPONDANCE
  filename <- paste0("images/", study, "/", polarity, "/default/",
                     std_info$quality[i], "_", cmpname, "_GR.png")
  png(file = filename, width = 1000, height = 500)
  plotChromPeakDensity(
    chr, pdp2, 
    peakCol = col_class[xdata$class[chromPeaks(chr)[, "column"]]],
    peakBg = paste0(col_class[
      xdata$class[chromPeaks(chr)[, "column"]]], "10"))
  dev.off()
  
  chr2 <- chromatogram(raw_data, mz = c((mz.i - mz.d), (mz.i + mz.d)),
                      aggregationFun = "max")
  chr2 <- findChromPeaks(chr2, param = cwp)
  delta_rt <- abs(chromPeaks(chr2)[, "rt"] - rt.i)
  pks <- data.frame(chromPeaks(chr2)[delta_rt < 60, , drop=FALSE])
  if (nrow(pks)) {
    pks2 <- pks[0, ]
    for(j in seq(length(levels(factor(pks$column))))){
      pks3 <- pks[pks$column == j, ]
      pks2 <- rbind(pks2, pks3[which.max(pks3$maxo),])
    }
    #pks2 <- pks2[pks2$column > 3, ]
    rtmin <- min(pks2$rtmin) - 5
    rtmax <- max(pks2$rtmax) + 5
    ylim <- c(0, max(pks$maxo, na.rm = TRUE))
    } else {
      rtmin <- std_info$RT[i] - 5
      rtmax <- std_info$RT[i] + 5
      ylim <- c(0, max(sapply(chr, intensity), na.rm = TRUE))
    }
  chr2 <- chromatogram(xdata, mz = c((mz.i - mz.d), (mz.i + mz.d)),
                       rt = c((rt.i - rt.d), (rt.i + rt.d)),
                      aggregationFun = "max")
  filename <- paste0("images/", study, "/", polarity, "/default/",
                     std_info$quality[i], "_", cmpname, "_GR_zoom.png")
  png(file = filename, width = 1000, height = 500)
  plotChromPeakDensity(
    chr2, pdp2, 
    peakCol = col_class[xdata$class[chromPeaks(chr2)[, "column"]]],
    peakBg = paste0(col_class[
      xdata$class[chromPeaks(chr2)[, "column"]]], "10"))
  dev.off()
}
```

# Conclusions
It seems that the processing workflow does not work very well for all compounds.  
  
It is working well with the following compounds (for these compounds there is only 1 peak detected in each sample, and the peaks from different samples are well grouped together):
  
- Arginine  
- Cysteine  
- Glycine  
  
It is also working well, but not in the best way for the following compounds (for these compounds there is >1 peak detected in at least 1 sample, althought the peaks from different samples are well grouped together):  
  
- Glutamic acid  
- Histidine  
- Lysine  
- Serine  
- Threonine  
  
Although if the following compound does not resolve well from a chromatographic point of view, and there is >1 peak detected in each sample, all detected peaks are well grouped together in 1 feature:  
  
- Glucose  
  
The following compounds start to be more problematic, since for all of them, a part of detecting >1 peak in at least 1 sample (except for tyrosine), we also got 2 different features due to an important shift in RT associated with the concentration of the compound in the sample:  
  
- Tyrosine  
- Alanine  
- Aspartic acid  
- Methionine  
- Phenylalanine  
- Proline  
- Valine  
  
Finally, following I mention the compounds that are not well solved from the chromatographic point of view, since they present large peaks and, in consequence, we got >1 peak per compound/sample and also >1 feature per compound:  
  
- Creatinine  
- Carnitine  
- (iso)Leucine  
  
The first problem that rise from this situation is that for features containing >1 peak from the same sample and they are not overlaped peaks (as it happens for glucose), if we use the method "maxint" (which selects the peak yielding the largest signal) when we are extracting the matrix for feature values, we will be underestaming the real intensity (in this case probably we should use the method "sum"); whereas for features containing >1 peak from the same sample that are overlaping peaks (as it happens for valine in IS-low), if we use the method "sum" (which sum the values of all peaks grouped in the same feature) we will be overestimating the real intensity (in the case probably we should use the method "maxint").  
  
At the same time, we also have a parallel problem related by the fact that for a same compound which is effected by a RT shift associated with the concentration of the compounds in the sample, we got 2 different features from the same compound depending on the concentration. They should be grouped all together in a same feature, because in the other case it will bring us to wrong conclusions.  
  
In front of these situations, we've decided to apply a "peak post-processing" step between "peak detection" and "peak grouping" steps. I'll deal with it in a separate Markdown document.  

# Session information
```{r}
Sys.time()-startpoint

devtools::session_info()
```

