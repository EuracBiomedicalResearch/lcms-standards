---
title: "LC-MS/MS standards"
author: "Andrea Vicini, Johannes Rainer, Vinicius Verri"
output:
  rmarkdown::html_document:
    highlight: pygments
    toc: true
    toc_depth: 3
    fig_width: 5
---

```{r style, echo = FALSE, results = 'asis', message = FALSE}
library(BiocStyle)
knitr::opts_chunk$set(echo = TRUE, message = FALSE)
```

**Last modified:** `r file.info("preprocessing-standards.Rmd")$mtime`<br />
**Compiled**: `r date()`

```{r general-settings, echo = FALSE}
mix <- 1
mix_name <- paste0("Mix", ifelse(mix < 10, paste0(0, mix), mix)) 
IMAGE_PATH <- paste0("images/preprocessing-standards/", tolower(mix_name),"/")
RDATA_PATH <- paste0("data/RData/preprocessing-standards/", tolower(mix_name), "/")
dir.create(IMAGE_PATH, showWarnings = FALSE, recursive = TRUE)
dir.create(RDATA_PATH, showWarnings = FALSE, recursive = TRUE)

## Define the *base* path where mzML files can be found. This is
## /data/massspec/mzML/ on the cluster
MZML_PATH <- "~/mix01/"
## MZML_PATH <- "/data/massspec/mzML/"

library(BiocParallel)
#' Set up parallel processing using 2 cores
if (.Platform$OS.type == "unix") {
    register(bpstart(MulticoreParam(2)))
} else {
    register(bpstart(SnowParam(2)))
}
```

# Introduction

In this document we perform the preprocessing and analysis of mzML files to
determine retention times and measured ions for the *standards*. These standards
are a collection of ~ 250 pure standards of polar metabolites which were used to
setup the HILIC-based LC-MS protocols to measure the polar metabolome in human
serum samples.


# Data preprocessing

Below we load all required libraries.

```{r libraries, message = FALSE, warning = FALSE}
  library(xcms)
library(pander)
#library(RColorBrewer)
library(MetaboCoreUtils)
#library(MsFeatures)
#library(SummarizedExperiment)
library(MetaboAnnotation)
#library(DBI)
#library(dplyr)
```

We next restrict to files with samples from a single standards mix.
```{r}
std_files <- read.table("data/std_serum_files.txt", header = TRUE)
std_files01 <- std_files[which(std_files$type == mix_name), ]
```

The list of standards that constitute the present sample mix are listed below
along with the expected retention time and the most abundant adduct for positive
and negative polarity as defined in a previous analysis.

```{r, echo = FALSE, results = "asis"}
std_dilution <- read.table("data/standards_dilution.txt",
                           sep = "\t", header = TRUE)
std_dilution$exactmass <- vapply(std_dilution$formula, 
                                  function(z) calculateMass(z), numeric(1))
std_dilution01 <- std_dilution[std_dilution$mix == mix, ]
pandoc.table(std_dilution01[, c("name", "formula", "RT", "POS", "NEG")], 
             style = "rmarkdown", split.tables = Inf,
             caption = paste0("Standards of ", mix_name))
```

We next import the MS data from all mzML files of this mix corresponding to 
positive mode and water matrix. 

```{r load-data, warning = FALSE, eval = !file.exists(paste0(RDATA_PATH, "processed_data.RData"))}
std_files01_WP <- std_files01[std_files01$polarity == "POS" &
                                grepl("^Water", std_files01$class), ]
fls_WP <- paste0(MZML_PATH, std_files01_WP$folder, "/", std_files01_WP$mzML)
data <- readMSData(fls_WP, pdata = new("NAnnotatedDataFrame", std_files01_WP),
                   mode = "onDisk")
```

Next we perform the chromatographic peak detection on all samples and
subsequently *refine* also the chromatographic peaks.

```{r peakdetection, eval = !file.exists(paste0(RDATA_PATH, "processed_data.RData"))}
cwp <- CentWaveParam(ppm = 50,
                     peakwidth = c(2, 20),
                     snthresh = 5,
                     mzdiff = 0.001,
                     prefilter = c(4, 300),
                     noise = 100,
                     integrate = 2)

data <- findChromPeaks(data, param = cwp) 
```


```{r refinement, message = FALSE, warning = FALSE, eval = !file.exists(paste0(RDATA_PATH, "processed_data.RData"))}
mnp <- MergeNeighboringPeaksParam(expandRt = 2.5, expandMz = 0.001,
                                  minProp = 3/4)
data <- refineChromPeaks(data, param = mnp)
```

Next we perform a correspondence analysis to group chromatographic peaks across
samples.

```{r correspondence, echo = FALSE, eval = !file.exists(paste0(RDATA_PATH, "processed_data.RData"))}
pdp <- PeakDensityParam(sampleGroups = rep("Water_POS", nrow(data)), bw = 1.8,
                        minFraction = 0.7, binSize = 0.02)
data <- groupChromPeaks(data, param = pdp)
```

Finally we fill-in missing peak data.
```{r gap-filling, echo = FALSE, eval = !file.exists(paste0(RDATA_PATH, "processed_data.RData"))}
## Gap-filling
data <- fillChromPeaks(data, param = ChromPeakAreaParam())
save(data, file = paste0(RDATA_PATH, "processed_data.RData"))
```

```{r correspondence-cached, echo = FALSE, eval = file.exists(paste0(RDATA_PATH, "processed_data.RData"))}
load(paste0(RDATA_PATH, "processed_data.RData"))
```

We compute log2 difference in concentration (between high and low concentration 
samples) t.test statistic and the realted p-value for each of the found features.

```{r}
fVlog2 <- log2(featureValues(data, value = "into", method = "sum", filled = TRUE))
high <- grep("High", colnames(fVlog2))
low <- grep("Low", colnames(fVlog2))

pvalues <- t(apply(fVlog2, 1, function(x) {
  res <- t.test(x[high], x[low], mu = 0)
  c(high_low_diff = unname(res$estimate[1] - res$estimate[2]), 
    pvalue = res$p.value)
}))
```

# Matching features to adducts of standards

```{r}
adducts <- c("[M+H]+", "[M+2H]2+", "[M+Na]+", "[M+K]+", "[M+NH4]+", 
             "[M+H-H2O]+", "[M+H+Na]2+", "[M+2Na]2+", "[M+H-NH3]+")
prm <- Mass2MzParam(adducts = adducts, ppm = 30)
fmat <- cbind(featureDefinitions(data), pvalues)
mtchs <- matchMz(fmat, std_dilution01, param =  prm, mzColname = "mzmed")
mtchs_sub <- mtchs[whichQuery(mtchs)]

```

  

```{r}
mD <- matchedData(mtchs_sub, columns = c("mzmed", "rtmed", "target_name", 
                                         "adduct", "score", "target_RT", 
                                         "target_POS", "high_low_diff", 
                                         "pvalue"))
pandoc.table(as.data.frame(mD), style = "rmarkdown", split.tables = Inf,
             caption = "Feature to standards matches")
```
```{r}
mD[order(mD$target_name), ]
length(unique(mD$target_name)) # 7 standards matched to features
```


# Session information

The R version and packages used in this analysis are listed below.

```{r sessioninfo}
sessionInfo()
```