---
title: "Determining retention times and measured ions for LC-MS/MS *standards"
author: "Andrea Vicini, Johannes Rainer, Vinicius Verri Hernandez"
output:
  rmarkdown::html_document:
    highlight: pygments
    toc: true
    toc_depth: 3
    fig_width: 5
---

```{r style, echo = FALSE, results = 'asis', message = FALSE}
library(BiocStyle)
knitr::opts_chunk$set(echo = TRUE, message = FALSE)
```

**Last modified:** `r file.info("preprocessing-standards-new.Rmd")$mtime`<br />
**Compiled**: `r date()`

# Introduction

In this document we perform the preprocessing and analysis of mzML files to
determine retention times and measured ions for the *standards*. These standards
are a collection of ~ 250 pure standards of polar metabolites which were used to
setup the HILIC-based LC-MS protocols to measure the polar metabolome in human
serum samples.

```{r}
# We select a given mix
mix <- 1
mix_name <- paste0("Mix", ifelse(mix < 10, paste0(0, mix), mix)) 
```

```{r general-settings, echo = FALSE}
IMAGE_PATH <- paste0("images/preprocessing-standards-new/", tolower(mix_name),"/")
RDATA_PATH <- paste0("data/RData/preprocessing-standards-new/", tolower(mix_name), "/")
dir.create(IMAGE_PATH, showWarnings = FALSE, recursive = TRUE)
dir.create(RDATA_PATH, showWarnings = FALSE, recursive = TRUE)

## Define the *base* path where mzML files can be found. This is
## /data/massspec/mzML/ on the cluster
MZML_PATH <- "~/mix01/"
## MZML_PATH <- "/data/massspec/mzML/"

library(BiocParallel)
#' Set up parallel processing using 2 cores
if (.Platform$OS.type == "unix") {
    register(bpstart(MulticoreParam(2)))
} else {
    register(bpstart(SnowParam(2)))
}
```

# Data preprocessing

Below we load all required libraries.

```{r libraries, message = FALSE, warning = FALSE}
library(xcms)
library(pander)
library(MetaboCoreUtils)
library(MetaboAnnotation)
# library(RColorBrewer)
# library(MsFeatures)
# library(SummarizedExperiment)
# library(DBI)
# library(dplyr)
```

We next restrict to files with samples from the selected standards mix.

```{r}
std_files <- read.table("data/std_serum_files.txt", header = TRUE)
std_files <- std_files[which(std_files$type == mix_name), ]
```

The list of standards that constitute the present sample mix are listed below
along with the expected retention time and the most abundant adduct for positive
and negative polarity as defined in a previous analysis.

```{r, echo = FALSE, results = "asis"}
std_dilution <- read.table("data/standards_dilution.txt",
                           sep = "\t", header = TRUE)
std_dilution$exactmass <- vapply(std_dilution$formula, 
                                  function(z) calculateMass(z), numeric(1))
std_dilution01 <- std_dilution[std_dilution$mix == mix, ]
pandoc.table(std_dilution01[, c("name", "formula", "RT", "POS", "NEG")], 
             style = "rmarkdown", split.tables = Inf,
             caption = paste0("Standards of ", mix_name))
```

We next import the MS data from all mzML files of this mix corresponding to 
positive mode and water matrix. 

```{r load-data, warning = FALSE, eval = !file.exists(paste0(RDATA_PATH, "processed_data.RData"))}
std_files_WP <- std_files[std_files$polarity == "POS" &
                                grepl("^Water", std_files$class), ]
fls_WP <- paste0(MZML_PATH, std_files_WP$folder, "/", std_files_WP$mzML)
data <- readMSData(fls_WP, pdata = new("NAnnotatedDataFrame", std_files_WP),
                   mode = "onDisk")
```

Next we perform the chromatographic peak detection on all samples and
subsequently *refine* also the chromatographic peaks.

```{r peakdetection, eval = !file.exists(paste0(RDATA_PATH, "processed_data.RData"))}
cwp <- CentWaveParam(ppm = 50,
                     peakwidth = c(2, 20),
                     snthresh = 5,
                     mzdiff = 0.001,
                     prefilter = c(4, 300),
                     noise = 100,
                     integrate = 2)

data <- findChromPeaks(data, param = cwp) 
```


```{r refinement, message = FALSE, warning = FALSE, eval = !file.exists(paste0(RDATA_PATH, "processed_data.RData"))}
mnp <- MergeNeighboringPeaksParam(expandRt = 2.5, expandMz = 0.001,
                                  minProp = 3/4)
data <- refineChromPeaks(data, param = mnp)
```

Next we perform a correspondence analysis to group chromatographic peaks across
samples.

```{r correspondence, echo = FALSE, eval = !file.exists(paste0(RDATA_PATH, "processed_data.RData"))}
pdp <- PeakDensityParam(sampleGroups = rep("Water_POS", nrow(data)), bw = 1.8,
                        minFraction = 0.7, binSize = 0.02)
data <- groupChromPeaks(data, param = pdp)
```

Finally we fill-in missing peak data.
```{r gap-filling, echo = FALSE, eval = !file.exists(paste0(RDATA_PATH, "processed_data.RData"))}
## Gap-filling
data <- fillChromPeaks(data, param = ChromPeakAreaParam())
save(data, file = paste0(RDATA_PATH, "processed_data.RData"))
```

```{r correspondence-cached, echo = FALSE, eval = file.exists(paste0(RDATA_PATH, "processed_data.RData"))}
load(paste0(RDATA_PATH, "processed_data.RData"))
```

We compute log2 difference in concentration (between high and low concentration 
samples) t.test statistic and the realted p-value for each of the found features.

```{r}
fVlog2 <- log2(featureValues(data, value = "into", method = "sum", filled = TRUE))
high <- grep("High", colnames(fVlog2))
low <- grep("Low", colnames(fVlog2))

ttest <- t(apply(fVlog2, 1, function(x) {
  res <- t.test(x[high], x[low], mu = 0)
  c(high_low_diff = unname(res$estimate[1] - res$estimate[2]),
    pvalue = res$p.value)
}))
```

# Matching features to adducts of standards

```{r}
adducts <- c("[M+H]+", "[M+2H]2+", "[M+Na]+", "[M+K]+", "[M+NH4]+",
             "[M+H-H2O]+", "[M+H+Na]2+", "[M+2Na]2+", "[M+H-NH3]+")
prm <- Mass2MzParam(adducts = adducts, ppm = 30)
fmat <- cbind(featureDefinitions(data), ttest)
mtchs <- matchMz(fmat, std_dilution01, param =  prm, mzColname = "mzmed")
mtchs_sub <- mtchs[whichQuery(mtchs)]

```

  

```{r}
mD <- matchedData(mtchs_sub, columns = c("mzmed", "rtmed", "target_name",
                                         "adduct", "score", "target_RT",
                                         "target_POS", "high_low_diff",
                                         "pvalue"))
mD <- mD[order(mD$target_name), ]
pandoc.table(as.data.frame(mD), style = "rmarkdown",
             split.tables = Inf, caption = "Feature to standards matches")
```

Only `r length(unique(mD$target_name))` standards of the `r nrow(std_dilution01)` 
standards in mix `r `mix` have at least a feature that was matched to them. 
The standards with no match are reported below.

```{r}
pandoc.table(std_dilution01[!std_dilution01$name %in% mD$target_name,
                            c("name", "formula", "RT", "POS", "NEG")],
             style = "rmarkdown", split.tables = Inf,
             caption = "Not matched standards")
```


### Annotating features using MS2 data

Next we extract for all matched features potentially measured MS2 spectra
and match them against MassBank in order to annotate them. We first extract 
spectra from MassBank database.

```{r}
library(RMariaDB)
library(MsBackendMassbank)

co <- dbConnect(MariaDB(), user = "avwork", dbname = "MassBank",
                 host = "localhost", pass = "massbank")
mbank <- Spectra(co, source = MsBackendMassbankSql())
mbank <- setBackend(mbank, MsBackendDataFrame()) # breaks with parallel processing
```

```{r}
data_ms2<- filterFile(data, file = which(data$mode != "FS"), keepFeatures = TRUE)
```

The following function (to avoid code repetition) takes the ids of
features `f_id`, checks which ones are also available for the given MS2 data
`data_ms2`. For these it extracts the corresponding spectra and matches them
against a reference database `mbank`. It returns a vector. Each entry contains
for a given feature the compound names of the spectra in `mbank` that were
matched to the spectra related to the feature.

```{r}
f_ms2_mtch <- function(data_ms2, f_id, mbank, case, recompute = FALSE)
{
  ids <- intersect(rownames(featureDefinitions(data_ms2)), f_id)
  sign_f_ms2 <- featureSpectra(data_ms2, msLevel = 2L,
                               return.type = "Spectra", ppm = 10,
                               features = ids)
  fn <- paste0(RDATA_PATH, "comp_", case, "_ms2_MassBank.RData")
  if(!file.exists(fn) | recompute)
  {
    mtches <- matchSpectra(sign_f_ms2, mbank,
                         param = CompareSpectraParam(requirePrecursor = FALSE,
                                                     ppm = 10))
    save(mtches, file = fn)
  }
  else load(fn)
  mtches <- mtches[whichQuery(mtches)]
  tmp <- aggregate(mtches$target_compound_name,
                   by = list(feature = mtches$feature_id),
                   function(x) paste0(unique(x), collapse = ";"))
  #tmp[tmp[, 2] == ""] <- NA
  res <- rep(NA, length(f_id))
  res[match(tmp[, 1], f_id)] <- tmp[, 2]
  res
}
```


```{r}
mD$ms2_matches <- f_ms2_mtch(data_ms2, rownames(mD), mbank, "WP")
pandoc.table(as.data.frame(mD), style = "rmarkdown", split.tables = Inf,
             caption = "Feature to standards and massbank matches")
```


# Session information

The R version and packages used in this analysis are listed below.

```{r sessioninfo}
sessionInfo()
```